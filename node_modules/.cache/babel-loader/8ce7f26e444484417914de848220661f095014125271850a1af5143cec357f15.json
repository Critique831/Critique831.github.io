{"ast":null,"code":"// leaderboardUtils.js\nexport function updateLeaderboard(level,steps){// Get current leaderboard data from local storage\nconst storedLeaderboard=JSON.parse(localStorage.getItem('leaderboard'))||[];// Find the existing entry for the current level\nconst existingEntryIndex=storedLeaderboard.findIndex(entry=>entry.level===level);// If an existing entry is found and the new steps are shorter, update the entry\nif(existingEntryIndex!==-1&&steps<storedLeaderboard[existingEntryIndex].steps){const updatedLeaderboard=[...storedLeaderboard];// Create a copy of the current leaderboard\n// Update the steps for the existing entry\nupdatedLeaderboard[existingEntryIndex]={level,steps};// Save the updated leaderboard to local storage\nlocalStorage.setItem('leaderboard',JSON.stringify(updatedLeaderboard));}// If no existing entry or the new steps are shorter, add a new entry\nelse if(existingEntryIndex===-1){const updatedLeaderboard=[...storedLeaderboard.filter(entry=>entry.level!==level),// Remove existing entries for the current level\n{level,steps}// Add the new entry\n];// Save the updated leaderboard to local storage\nlocalStorage.setItem('leaderboard',JSON.stringify(updatedLeaderboard));}}","map":{"version":3,"names":["updateLeaderboard","level","steps","storedLeaderboard","JSON","parse","localStorage","getItem","existingEntryIndex","findIndex","entry","updatedLeaderboard","setItem","stringify","filter"],"sources":["C:/Users/Asus/Desktop/School/TNP/react-memorygame/src/leaderboardUtils.js"],"sourcesContent":["// leaderboardUtils.js\r\n\r\nexport function updateLeaderboard(level, steps) {\r\n    // Get current leaderboard data from local storage\r\n    const storedLeaderboard = JSON.parse(localStorage.getItem('leaderboard')) || [];\r\n  \r\n    // Find the existing entry for the current level\r\n    const existingEntryIndex = storedLeaderboard.findIndex((entry) => entry.level === level);\r\n  \r\n    // If an existing entry is found and the new steps are shorter, update the entry\r\n    if (existingEntryIndex !== -1 && steps < storedLeaderboard[existingEntryIndex].steps) {\r\n      const updatedLeaderboard = [...storedLeaderboard]; // Create a copy of the current leaderboard\r\n  \r\n      // Update the steps for the existing entry\r\n      updatedLeaderboard[existingEntryIndex] = { level, steps };\r\n  \r\n      // Save the updated leaderboard to local storage\r\n      localStorage.setItem('leaderboard', JSON.stringify(updatedLeaderboard));\r\n    }\r\n    // If no existing entry or the new steps are shorter, add a new entry\r\n    else if (existingEntryIndex === -1) {\r\n      const updatedLeaderboard = [\r\n        ...storedLeaderboard.filter((entry) => entry.level !== level), // Remove existing entries for the current level\r\n        { level, steps }, // Add the new entry\r\n      ];\r\n  \r\n      // Save the updated leaderboard to local storage\r\n      localStorage.setItem('leaderboard', JSON.stringify(updatedLeaderboard));\r\n    }\r\n  }\r\n  "],"mappings":"AAAA;AAEA,MAAO,SAAS,CAAAA,iBAAiBA,CAACC,KAAK,CAAEC,KAAK,CAAE,CAC5C;AACA,KAAM,CAAAC,iBAAiB,CAAGC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACC,OAAO,CAAC,aAAa,CAAC,CAAC,EAAI,EAAE,CAE/E;AACA,KAAM,CAAAC,kBAAkB,CAAGL,iBAAiB,CAACM,SAAS,CAAEC,KAAK,EAAKA,KAAK,CAACT,KAAK,GAAKA,KAAK,CAAC,CAExF;AACA,GAAIO,kBAAkB,GAAK,CAAC,CAAC,EAAIN,KAAK,CAAGC,iBAAiB,CAACK,kBAAkB,CAAC,CAACN,KAAK,CAAE,CACpF,KAAM,CAAAS,kBAAkB,CAAG,CAAC,GAAGR,iBAAiB,CAAC,CAAE;AAEnD;AACAQ,kBAAkB,CAACH,kBAAkB,CAAC,CAAG,CAAEP,KAAK,CAAEC,KAAM,CAAC,CAEzD;AACAI,YAAY,CAACM,OAAO,CAAC,aAAa,CAAER,IAAI,CAACS,SAAS,CAACF,kBAAkB,CAAC,CAAC,CACzE,CACA;AAAA,IACK,IAAIH,kBAAkB,GAAK,CAAC,CAAC,CAAE,CAClC,KAAM,CAAAG,kBAAkB,CAAG,CACzB,GAAGR,iBAAiB,CAACW,MAAM,CAAEJ,KAAK,EAAKA,KAAK,CAACT,KAAK,GAAKA,KAAK,CAAC,CAAE;AAC/D,CAAEA,KAAK,CAAEC,KAAM,CAAG;AAAA,CACnB,CAED;AACAI,YAAY,CAACM,OAAO,CAAC,aAAa,CAAER,IAAI,CAACS,SAAS,CAACF,kBAAkB,CAAC,CAAC,CACzE,CACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}